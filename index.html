<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="default">
  <meta name="apple-mobile-web-app-title" content="Photo Editor">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="theme-color" content="#2563eb">
  <link rel="manifest" href="manifest.json">
  <title>Teacher Photo Editor</title>
  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    :root {
      --blue: #2563eb;
      --blue-dark: #1e40af;
      --green: #16a34a;
      --amber-light: #fef3c7;
      --red: #dc2626;
      --gray-50: #f8fafc;
      --gray-100: #f1f5f9;
      --gray-200: #e2e8f0;
      --gray-300: #cbd5e1;
      --gray-500: #64748b;
      --gray-700: #334155;
      --gray-900: #0f172a;
      --radius: 12px;
      --safe-bottom: env(safe-area-inset-bottom, 0px);
      --safe-top: env(safe-area-inset-top, 0px);
    }

    html, body {
      height: 100%;
      overflow: hidden;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--gray-100);
      color: var(--gray-900);
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }

    .app { display: flex; flex-direction: column; height: 100%; }
    .screen { display: none; flex-direction: column; height: 100%; }
    .screen.active { display: flex; }

    /* ===== HEADER ===== */
    .header {
      background: var(--blue);
      color: white;
      padding: 12px 16px;
      padding-top: calc(12px + var(--safe-top));
      display: flex;
      align-items: center;
      gap: 12px;
      flex-shrink: 0;
      z-index: 10;
    }
    .header h1 { font-size: 1.15rem; font-weight: 600; }
    .header .subtitle { font-size: 0.75rem; opacity: 0.8; }
    .header-right { margin-left: auto; display: flex; gap: 8px; }
    .header-btn {
      background: rgba(255,255,255,0.2);
      border: none;
      color: white;
      padding: 8px 14px;
      border-radius: 8px;
      font-size: 0.85rem;
      font-weight: 500;
      cursor: pointer;
    }
    .header-btn:active { background: rgba(255,255,255,0.35); }

    /* ===== GALLERY ===== */
    .gallery-actions {
      display: flex;
      gap: 8px;
      padding: 12px 16px;
      flex-shrink: 0;
    }
    .action-btn {
      flex: 1;
      padding: 14px 8px;
      border: 2px dashed var(--gray-300);
      border-radius: var(--radius);
      background: white;
      font-size: 0.9rem;
      font-weight: 500;
      color: var(--gray-700);
      cursor: pointer;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
    }
    .action-btn .icon { font-size: 1.6rem; }
    .action-btn:active { background: var(--gray-50); border-color: var(--blue); }

    .gallery-status-bar {
      padding: 0 16px 8px;
      display: flex;
      align-items: center;
      gap: 8px;
      flex-shrink: 0;
    }
    .gallery-status-text {
      font-size: 0.8rem;
      color: var(--gray-500);
      flex: 1;
    }
    .batch-crop-btn {
      padding: 6px 12px;
      border: none;
      border-radius: 6px;
      background: var(--amber-light);
      color: #92400e;
      font-size: 0.75rem;
      font-weight: 600;
      cursor: pointer;
    }
    .batch-crop-btn:active { background: #fde68a; }
    .batch-crop-btn.hidden { display: none; }

    .gallery-grid {
      flex: 1;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      padding: 0 12px 12px;
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 8px;
      align-content: start;
    }

    .gallery-item {
      position: relative;
      aspect-ratio: 1;
      border-radius: 10px;
      overflow: hidden;
      background: var(--gray-200);
      cursor: pointer;
    }
    .gallery-item img { width: 100%; height: 100%; object-fit: cover; }
    .gallery-item .item-name {
      position: absolute; bottom: 0; left: 0; right: 0;
      padding: 3px 6px;
      background: linear-gradient(transparent, rgba(0,0,0,0.7));
      color: white; font-size: 0.65rem;
      white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
    }
    .gallery-item .item-badge {
      position: absolute; top: 4px; left: 4px;
      background: var(--green); color: white;
      font-size: 0.55rem; padding: 2px 5px; border-radius: 4px; font-weight: 600;
    }
    .gallery-item .item-check {
      position: absolute; top: 4px; right: 4px;
      width: 22px; height: 22px; border-radius: 50%;
      border: 2px solid white; background: rgba(0,0,0,0.3);
      display: flex; align-items: center; justify-content: center;
      color: white; font-size: 0.7rem;
    }
    .gallery-item.selected .item-check { background: var(--blue); border-color: var(--blue); }

    .gallery-empty {
      grid-column: 1 / -1;
      text-align: center;
      padding: 60px 20px;
      color: var(--gray-500);
    }
    .gallery-empty .empty-icon { font-size: 3rem; margin-bottom: 12px; }

    /* Bottom bar */
    .gallery-bottom {
      display: none;
      padding: 12px 16px;
      padding-bottom: calc(12px + var(--safe-bottom));
      background: white;
      border-top: 1px solid var(--gray-200);
      gap: 8px;
      flex-shrink: 0;
    }
    .gallery-bottom.visible { display: flex; }
    .bottom-btn {
      flex: 1;
      padding: 12px;
      border: none;
      border-radius: var(--radius);
      font-size: 0.85rem;
      font-weight: 600;
      cursor: pointer;
      text-align: center;
    }
    .bottom-btn.primary { background: var(--blue); color: white; }
    .bottom-btn.primary:active { background: var(--blue-dark); }
    .bottom-btn.danger { background: #fee2e2; color: var(--red); }
    .bottom-btn.secondary { background: var(--gray-100); color: var(--gray-700); }

    /* ===== TOAST ===== */
    .toast {
      position: fixed;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%) translateY(20px);
      background: var(--gray-900);
      color: white;
      padding: 10px 20px;
      border-radius: 8px;
      font-size: 0.85rem;
      font-weight: 500;
      z-index: 100;
      opacity: 0;
      transition: opacity 0.3s, transform 0.3s;
      pointer-events: none;
      white-space: nowrap;
    }
    .toast.show {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
    }

    /* ===== CONFIRM DIALOG ===== */
    .confirm-overlay {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.5);
      z-index: 50;
      justify-content: center;
      align-items: center;
    }
    .confirm-overlay.visible { display: flex; }
    .confirm-dialog {
      background: white;
      border-radius: 16px;
      padding: 24px;
      margin: 20px;
      max-width: 320px;
      width: 100%;
      text-align: center;
    }
    .confirm-dialog .confirm-title { font-weight: 600; font-size: 1rem; margin-bottom: 8px; }
    .confirm-dialog .confirm-msg { font-size: 0.85rem; color: var(--gray-500); margin-bottom: 20px; }
    .confirm-buttons { display: flex; gap: 10px; }
    .confirm-buttons button {
      flex: 1;
      padding: 12px;
      border: none;
      border-radius: var(--radius);
      font-size: 0.9rem;
      font-weight: 600;
      cursor: pointer;
    }
    .confirm-btn-cancel { background: var(--gray-100); color: var(--gray-700); }
    .confirm-btn-ok { background: var(--red); color: white; }

    /* ===== BATCH PROGRESS ===== */
    .batch-overlay {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.6);
      z-index: 50;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      gap: 16px;
    }
    .batch-overlay.visible { display: flex; }
    .batch-card {
      background: white;
      border-radius: 16px;
      padding: 28px 32px;
      text-align: center;
      max-width: 300px;
      width: 90%;
    }
    .batch-card .batch-title { font-weight: 600; margin-bottom: 12px; }
    .batch-progress-bar {
      height: 8px;
      background: var(--gray-200);
      border-radius: 4px;
      overflow: hidden;
      margin-bottom: 8px;
    }
    .batch-progress-fill {
      height: 100%;
      background: var(--blue);
      border-radius: 4px;
      transition: width 0.2s;
      width: 0%;
    }
    .batch-card .batch-status { font-size: 0.8rem; color: var(--gray-500); }

    /* ===== EDITOR ===== */
    .editor-header {
      background: var(--gray-900);
      color: white;
      padding: 10px 12px;
      padding-top: calc(10px + var(--safe-top));
      display: flex;
      align-items: center;
      gap: 8px;
      flex-shrink: 0;
      z-index: 10;
    }
    .editor-back {
      background: none; border: none; color: white;
      font-size: 1.4rem; padding: 4px 8px; cursor: pointer;
    }
    .editor-name-input {
      flex: 1;
      background: rgba(255,255,255,0.1);
      border: none; color: white;
      padding: 8px 12px; border-radius: 8px; font-size: 0.95rem;
    }
    .editor-name-input::placeholder { color: rgba(255,255,255,0.5); }
    .editor-name-input:focus { outline: none; background: rgba(255,255,255,0.2); }
    .editor-counter { font-size: 0.75rem; opacity: 0.7; white-space: nowrap; }

    .editor-canvas-area {
      flex: 1;
      background: var(--gray-900);
      display: flex;
      justify-content: center;
      align-items: center;
      position: relative;
      overflow: hidden;
      touch-action: none;
    }

    .canvas-container { position: relative; display: inline-block; line-height: 0; }
    #photo-canvas { max-width: 100%; max-height: 100%; }

    /* Auto-crop banner */
    .auto-crop-banner {
      display: none;
      position: absolute;
      top: 12px; left: 12px; right: 12px;
      background: rgba(37, 99, 235, 0.95);
      color: white;
      border-radius: var(--radius);
      padding: 12px 14px;
      z-index: 20;
      flex-direction: column;
      gap: 8px;
    }
    .auto-crop-banner.visible { display: flex; }
    .auto-crop-banner .banner-text { font-size: 0.85rem; font-weight: 500; }
    .auto-crop-banner .banner-sub { font-size: 0.75rem; opacity: 0.85; }
    .banner-buttons { display: flex; gap: 8px; }
    .banner-btn {
      flex: 1; padding: 10px; border: none; border-radius: 8px;
      font-size: 0.85rem; font-weight: 600; cursor: pointer;
    }
    .banner-btn.accept { background: white; color: var(--blue); }
    .banner-btn.accept:active { background: var(--gray-100); }
    .banner-btn.manual { background: rgba(255,255,255,0.2); color: white; }
    .banner-btn.manual:active { background: rgba(255,255,255,0.35); }
    .banner-btn.skip { background: rgba(255,255,255,0.15); color: rgba(255,255,255,0.8); }

    /* Scanning spinner */
    .scan-overlay {
      display: none;
      position: absolute; inset: 0;
      background: rgba(0,0,0,0.5);
      z-index: 25;
      justify-content: center; align-items: center;
      flex-direction: column; gap: 12px;
    }
    .scan-overlay.visible { display: flex; }
    .scan-spinner {
      width: 40px; height: 40px;
      border: 3px solid rgba(255,255,255,0.3);
      border-top-color: white;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    .scan-text { color: white; font-size: 0.9rem; }

    /* Crop overlay */
    .crop-overlay {
      display: none;
      position: absolute; top: 0; left: 0;
      width: 100%; height: 100%;
      cursor: crosshair; z-index: 15;
    }
    .crop-overlay.active { display: block; }
    .crop-shade { position: absolute; background: rgba(0,0,0,0.55); }
    .crop-selection {
      position: absolute;
      border: 2px solid white;
      box-shadow: 0 0 0 1px rgba(0,0,0,0.3);
      display: none;
    }
    .crop-selection.visible { display: block; }
    .crop-selection .crop-grid-line { position: absolute; background: rgba(255,255,255,0.3); }
    .crop-selection .crop-grid-line.h1 { left: 0; right: 0; top: 33.33%; height: 1px; }
    .crop-selection .crop-grid-line.h2 { left: 0; right: 0; top: 66.67%; height: 1px; }
    .crop-selection .crop-grid-line.v1 { top: 0; bottom: 0; left: 33.33%; width: 1px; }
    .crop-selection .crop-grid-line.v2 { top: 0; bottom: 0; left: 66.67%; width: 1px; }

    .crop-handle {
      position: absolute; width: 28px; height: 28px; background: transparent;
    }
    .crop-handle::after {
      content: ''; position: absolute; background: white;
    }
    .crop-handle.nw { top: -14px; left: -14px; cursor: nw-resize; }
    .crop-handle.nw::after { top: 12px; left: 12px; width: 16px; height: 3px; }
    .crop-handle.ne { top: -14px; right: -14px; cursor: ne-resize; }
    .crop-handle.ne::after { top: 12px; right: 12px; width: 16px; height: 3px; }
    .crop-handle.sw { bottom: -14px; left: -14px; cursor: sw-resize; }
    .crop-handle.sw::after { bottom: 12px; left: 12px; width: 16px; height: 3px; }
    .crop-handle.se { bottom: -14px; right: -14px; cursor: se-resize; }
    .crop-handle.se::after { bottom: 12px; right: 12px; width: 16px; height: 3px; }
    .crop-handle .corner-v {
      position: absolute; background: white; width: 3px; height: 16px;
    }
    .crop-handle.nw .corner-v { top: 12px; left: 12px; }
    .crop-handle.ne .corner-v { top: 12px; right: 12px; }
    .crop-handle.sw .corner-v { bottom: 12px; left: 12px; }
    .crop-handle.se .corner-v { bottom: 12px; right: 12px; }

    /* Editor toolbar */
    .editor-toolbar {
      display: flex;
      background: var(--gray-900);
      padding: 8px 12px;
      padding-bottom: calc(8px + var(--safe-bottom));
      gap: 4px;
      flex-shrink: 0;
      z-index: 10;
    }
    .tool-btn {
      flex: 1;
      display: flex; flex-direction: column; align-items: center; gap: 3px;
      padding: 8px 4px; border: none; border-radius: 8px;
      background: transparent;
      color: rgba(255,255,255,0.7);
      font-size: 0.65rem; font-weight: 500; cursor: pointer;
    }
    .tool-btn .tool-icon { font-size: 1.3rem; }
    .tool-btn:active, .tool-btn.active { background: rgba(255,255,255,0.15); color: white; }

    .crop-toolbar {
      display: none;
      background: var(--gray-900);
      padding: 10px 16px;
      padding-bottom: calc(10px + var(--safe-bottom));
      gap: 10px;
      flex-shrink: 0;
      z-index: 10;
    }
    .crop-toolbar.visible { display: flex; }
    .crop-action-btn {
      flex: 1; padding: 12px; border: none;
      border-radius: var(--radius);
      font-size: 0.9rem; font-weight: 600; cursor: pointer;
    }
    .crop-action-btn.apply { background: var(--green); color: white; }
    .crop-action-btn.apply:active { background: #15803d; }
    .crop-action-btn.cancel { background: rgba(255,255,255,0.1); color: white; }
    .crop-action-btn.cancel:active { background: rgba(255,255,255,0.2); }

    .nav-arrows {
      position: absolute; bottom: 10px; left: 50%;
      transform: translateX(-50%);
      display: flex; gap: 16px; z-index: 10;
    }
    .nav-arrow {
      width: 40px; height: 40px; border-radius: 50%;
      background: rgba(0,0,0,0.4); border: none;
      color: white; font-size: 1.2rem; cursor: pointer;
      display: flex; align-items: center; justify-content: center;
    }
    .nav-arrow:active { background: rgba(0,0,0,0.6); }
    .nav-arrow:disabled { opacity: 0.3; }

    .hidden { display: none !important; }

    @media (min-width: 768px) {
      .gallery-grid { grid-template-columns: repeat(5, 1fr); }
    }
  </style>
</head>
<body>
<div class="app">

  <!-- ===== GALLERY SCREEN ===== -->
  <div class="screen active" id="screen-gallery">
    <div class="header">
      <div>
        <h1>Teacher Photo Editor</h1>
        <div class="subtitle">Snap, name, crop &amp; save student projects</div>
      </div>
      <div class="header-right">
        <button class="header-btn" id="btn-select-mode">Select</button>
        <button class="header-btn" id="btn-save-all">Save All</button>
      </div>
    </div>

    <div class="gallery-actions">
      <div class="action-btn" id="btn-camera">
        <span class="icon">&#128247;</span>
        Take Photo
      </div>
      <div class="action-btn" id="btn-upload">
        <span class="icon">&#128194;</span>
        Upload Photos
      </div>
    </div>

    <div class="gallery-status-bar">
      <span class="gallery-status-text" id="gallery-status"></span>
      <button class="batch-crop-btn hidden" id="btn-batch-crop">Auto Crop All</button>
    </div>

    <div class="gallery-grid" id="gallery-grid">
      <div class="gallery-empty">
        <div class="empty-icon">&#128247;</div>
        <p>No photos yet!</p>
        <p style="margin-top:8px;font-size:0.85rem;">Take photos or upload from your gallery to get started.</p>
      </div>
    </div>

    <div class="gallery-bottom" id="gallery-bottom">
      <button class="bottom-btn secondary" id="btn-deselect">Cancel</button>
      <button class="bottom-btn danger" id="btn-delete-selected">Delete</button>
      <button class="bottom-btn primary" id="btn-save-selected">Save Selected</button>
    </div>

    <input type="file" id="file-camera" accept="image/*" capture="environment" class="hidden">
    <input type="file" id="file-upload" accept="image/*" multiple class="hidden">
  </div>

  <!-- ===== EDITOR SCREEN ===== -->
  <div class="screen" id="screen-editor">
    <div class="editor-header">
      <button class="editor-back" id="btn-back">&#x2190;</button>
      <input type="text" class="editor-name-input" id="editor-name" placeholder="Name this photo...">
      <span class="editor-counter" id="editor-counter"></span>
    </div>

    <div class="editor-canvas-area" id="editor-canvas-area">
      <div class="canvas-container" id="canvas-container">
        <canvas id="photo-canvas"></canvas>
        <div class="crop-overlay" id="crop-overlay">
          <div class="crop-shade" id="shade-top"></div>
          <div class="crop-shade" id="shade-right"></div>
          <div class="crop-shade" id="shade-bottom"></div>
          <div class="crop-shade" id="shade-left"></div>
          <div class="crop-selection" id="crop-selection">
            <div class="crop-grid-line h1"></div>
            <div class="crop-grid-line h2"></div>
            <div class="crop-grid-line v1"></div>
            <div class="crop-grid-line v2"></div>
            <div class="crop-handle nw" data-handle="nw"><span class="corner-v"></span></div>
            <div class="crop-handle ne" data-handle="ne"><span class="corner-v"></span></div>
            <div class="crop-handle sw" data-handle="sw"><span class="corner-v"></span></div>
            <div class="crop-handle se" data-handle="se"><span class="corner-v"></span></div>
          </div>
        </div>
      </div>

      <div class="auto-crop-banner" id="auto-crop-banner">
        <div>
          <div class="banner-text">Auto-crop detected</div>
          <div class="banner-sub">We found the project boundary in this photo</div>
        </div>
        <div class="banner-buttons">
          <button class="banner-btn accept" id="btn-accept-auto">Accept</button>
          <button class="banner-btn manual" id="btn-adjust-auto">Adjust</button>
          <button class="banner-btn skip" id="btn-skip-auto">Skip</button>
        </div>
      </div>

      <div class="scan-overlay" id="scan-overlay">
        <div class="scan-spinner"></div>
        <div class="scan-text">Scanning for project edges...</div>
      </div>

      <div class="nav-arrows">
        <button class="nav-arrow" id="btn-prev">&#x2039;</button>
        <button class="nav-arrow" id="btn-next">&#x203A;</button>
      </div>
    </div>

    <div class="editor-toolbar" id="editor-toolbar">
      <button class="tool-btn" id="tool-rotate-left">
        <span class="tool-icon">&#x21BA;</span>Rotate L
      </button>
      <button class="tool-btn" id="tool-rotate-right">
        <span class="tool-icon">&#x21BB;</span>Rotate R
      </button>
      <button class="tool-btn" id="tool-auto-crop">
        <span class="tool-icon">&#x2728;</span>Auto
      </button>
      <button class="tool-btn" id="tool-flatten">
        <span class="tool-icon">&#x25F1;</span>Flatten
      </button>
      <button class="tool-btn" id="tool-manual-crop">
        <span class="tool-icon">&#x2702;</span>Crop
      </button>
      <button class="tool-btn" id="tool-undo">
        <span class="tool-icon">&#x21A9;</span>Undo
      </button>
      <button class="tool-btn" id="tool-save">
        <span class="tool-icon">&#x2B73;</span>Save
      </button>
    </div>

    <div class="crop-toolbar" id="crop-toolbar">
      <button class="crop-action-btn cancel" id="btn-crop-cancel">Cancel</button>
      <button class="crop-action-btn apply" id="btn-crop-apply">Apply Crop</button>
    </div>
  </div>

</div>

<!-- Toast notification -->
<div class="toast" id="toast"></div>

<!-- Confirm dialog -->
<div class="confirm-overlay" id="confirm-overlay">
  <div class="confirm-dialog">
    <div class="confirm-title" id="confirm-title">Delete photos?</div>
    <div class="confirm-msg" id="confirm-msg">This cannot be undone.</div>
    <div class="confirm-buttons">
      <button class="confirm-btn-cancel" id="confirm-cancel">Cancel</button>
      <button class="confirm-btn-ok" id="confirm-ok">Delete</button>
    </div>
  </div>
</div>

<!-- Batch progress -->
<div class="batch-overlay" id="batch-overlay">
  <div class="batch-card">
    <div class="batch-title" id="batch-title">Auto-cropping all photos...</div>
    <div class="batch-progress-bar">
      <div class="batch-progress-fill" id="batch-progress-fill"></div>
    </div>
    <div class="batch-status" id="batch-status">0 / 0</div>
  </div>
</div>

<script>
(function() {
  'use strict';

  // ===== STATE =====
  const photos = [];
  let activeIndex = -1;
  let selectMode = false;
  let cropMode = false;
  let cropRect = null;
  let cropStart = null;
  let draggingHandle = null;
  let movingCrop = false;
  let moveStart = null;
  let autoCropResult = null;
  let confirmCallback = null;
  let longPressConsumed = false; // global flag to suppress click after long-press

  // ===== DOM REFS =====
  const screenGallery = document.getElementById('screen-gallery');
  const screenEditor  = document.getElementById('screen-editor');
  const galleryGrid   = document.getElementById('gallery-grid');
  const galleryStatus = document.getElementById('gallery-status');
  const galleryBottom = document.getElementById('gallery-bottom');
  const fileCamera    = document.getElementById('file-camera');
  const fileUpload    = document.getElementById('file-upload');
  const editorName    = document.getElementById('editor-name');
  const editorCounter = document.getElementById('editor-counter');
  const canvas        = document.getElementById('photo-canvas');
  const ctx           = canvas.getContext('2d');
  const editorCanvasArea = document.getElementById('editor-canvas-area');
  const cropOverlay   = document.getElementById('crop-overlay');
  const cropSelection = document.getElementById('crop-selection');
  const editorToolbar = document.getElementById('editor-toolbar');
  const cropToolbar   = document.getElementById('crop-toolbar');
  const autoCropBanner = document.getElementById('auto-crop-banner');
  const scanOverlay   = document.getElementById('scan-overlay');
  const toastEl       = document.getElementById('toast');
  const confirmOverlay = document.getElementById('confirm-overlay');
  const batchOverlay  = document.getElementById('batch-overlay');
  const batchFill     = document.getElementById('batch-progress-fill');
  const batchStatus   = document.getElementById('batch-status');
  const btnBatchCrop  = document.getElementById('btn-batch-crop');
  const btnSelectMode = document.getElementById('btn-select-mode');

  // ===== HELPERS =====
  function escHtml(str) {
    const d = document.createElement('div');
    d.textContent = str;
    return d.innerHTML;
  }

  let toastTimer;
  function showToast(msg) {
    toastEl.textContent = msg;
    toastEl.classList.add('show');
    clearTimeout(toastTimer);
    toastTimer = setTimeout(() => toastEl.classList.remove('show'), 2200);
  }

  function showConfirm(title, msg, okLabel, cb) {
    document.getElementById('confirm-title').textContent = title;
    document.getElementById('confirm-msg').textContent = msg;
    document.getElementById('confirm-ok').textContent = okLabel;
    confirmCallback = cb;
    confirmOverlay.classList.add('visible');
  }
  document.getElementById('confirm-cancel').addEventListener('click', () => {
    confirmOverlay.classList.remove('visible');
    confirmCallback = null;
  });
  document.getElementById('confirm-ok').addEventListener('click', () => {
    confirmOverlay.classList.remove('visible');
    if (confirmCallback) { confirmCallback(); confirmCallback = null; }
  });

  function showScreen(name) {
    screenGallery.classList.toggle('active', name === 'gallery');
    screenEditor.classList.toggle('active', name === 'editor');
  }

  // ===== SELECT MODE BUTTON =====
  btnSelectMode.addEventListener('click', () => {
    if (selectMode) {
      // Exit select mode
      photos.forEach(p => p.selected = false);
      selectMode = false;
    } else {
      selectMode = true;
    }
    updateSelectModeUI();
    renderGallery();
  });

  function updateSelectModeUI() {
    btnSelectMode.textContent = selectMode ? 'Done' : 'Select';
  }

  // ===== GALLERY =====
  document.getElementById('btn-camera').addEventListener('click', () => fileCamera.click());
  document.getElementById('btn-upload').addEventListener('click', () => fileUpload.click());

  fileCamera.addEventListener('change', () => {
    handleFiles(fileCamera.files, true);
    fileCamera.value = '';
  });
  fileUpload.addEventListener('change', () => {
    handleFiles(fileUpload.files, true);
    fileUpload.value = '';
  });

  function handleFiles(files, openFirst) {
    const firstNewIndex = photos.length;
    const imageFiles = Array.from(files).filter(f => f.type.startsWith('image/'));
    if (imageFiles.length === 0) return;
    let loaded = 0;

    imageFiles.forEach((file, fileIdx) => {
      const reader = new FileReader();
      reader.onload = (e) => {
        const img = new Image();
        img.onload = () => {
          const baseName = file.name.replace(/\.[^.]+$/, '');
          const photo = {
            id: Date.now() + '_' + Math.random().toString(36).slice(2,7),
            name: baseName,
            originalImg: img,
            currentImg: img,
            rotation: 0,
            cropped: false,
            selected: false,
            thumbCache: null,
          };
          photos.splice(firstNewIndex + fileIdx, 0, photo);
          loaded++;
          if (loaded === imageFiles.length) {
            renderGallery();
            if (openFirst) openEditor(firstNewIndex);
          }
        };
        img.src = e.target.result;
      };
      reader.readAsDataURL(file);
    });
  }

  function renderGallery() {
    galleryGrid.innerHTML = '';
    updateSelectModeUI();
    if (photos.length === 0) {
      galleryGrid.innerHTML = `
        <div class="gallery-empty">
          <div class="empty-icon">&#128247;</div>
          <p>No photos yet!</p>
          <p style="margin-top:8px;font-size:0.85rem;">Take photos or upload from your gallery to get started.</p>
        </div>`;
      galleryStatus.textContent = '';
      galleryBottom.classList.remove('visible');
      btnBatchCrop.classList.add('hidden');
      return;
    }

    const cropped = photos.filter(p => p.cropped).length;
    const uncropped = photos.length - cropped;
    galleryStatus.textContent = `${photos.length} photo${photos.length !== 1 ? 's' : ''} \u00B7 ${cropped} cropped`;
    btnBatchCrop.classList.toggle('hidden', uncropped === 0);

    photos.forEach((photo, idx) => {
      const div = document.createElement('div');
      div.className = 'gallery-item' + (photo.selected ? ' selected' : '');
      div.innerHTML = `
        <img src="${getThumbSrc(photo)}" alt="">
        <div class="item-name">${escHtml(photo.name || 'Untitled')}</div>
        ${photo.cropped ? '<div class="item-badge">Cropped</div>' : ''}
        <div class="item-check">${photo.selected ? '&#x2713;' : ''}</div>
      `;
      // Touch: long-press to enter select mode
      let pressTimer = null;
      div.addEventListener('touchstart', () => {
        longPressConsumed = false;
        pressTimer = setTimeout(() => {
          longPressConsumed = true;
          selectMode = true;
          photo.selected = true;
          updateSelectModeUI();
          renderGallery();
        }, 500);
      }, { passive: true });
      div.addEventListener('touchend', () => { clearTimeout(pressTimer); });
      div.addEventListener('touchmove', () => { clearTimeout(pressTimer); longPressConsumed = false; });

      div.addEventListener('click', (e) => {
        // Suppress click that follows a long-press
        if (longPressConsumed) { longPressConsumed = false; e.preventDefault(); return; }
        if (selectMode) {
          photo.selected = !photo.selected;
          renderGallery();
          return;
        }
        openEditor(idx);
      });

      galleryGrid.appendChild(div);
    });

    const anySelected = photos.some(p => p.selected);
    galleryBottom.classList.toggle('visible', anySelected || selectMode);
  }

  function getThumbSrc(photo) {
    if (photo.thumbCache) return photo.thumbCache;
    const tmpC = document.createElement('canvas');
    const tmpCtx = tmpC.getContext('2d');
    const img = photo.currentImg;
    const rot = photo.rotation;
    let w, h;
    if (rot === 90 || rot === 270) { w = img.height; h = img.width; }
    else { w = img.width; h = img.height; }
    const scale = Math.min(200 / w, 200 / h, 1);
    tmpC.width = Math.round(w * scale);
    tmpC.height = Math.round(h * scale);
    tmpCtx.translate(tmpC.width / 2, tmpC.height / 2);
    tmpCtx.rotate(rot * Math.PI / 180);
    tmpCtx.drawImage(img, -img.width * scale / 2, -img.height * scale / 2, img.width * scale, img.height * scale);
    photo.thumbCache = tmpC.toDataURL('image/jpeg', 0.6);
    return photo.thumbCache;
  }

  function invalidateThumb(photo) {
    photo.thumbCache = null;
  }

  // Deselect / exit select mode
  document.getElementById('btn-deselect').addEventListener('click', () => {
    photos.forEach(p => p.selected = false);
    selectMode = false;
    updateSelectModeUI();
    renderGallery();
  });

  // Delete selected with confirmation
  document.getElementById('btn-delete-selected').addEventListener('click', () => {
    const count = photos.filter(p => p.selected).length;
    if (count === 0) return;
    showConfirm(
      `Delete ${count} photo${count !== 1 ? 's' : ''}?`,
      'This cannot be undone.',
      'Delete',
      () => {
        for (let i = photos.length - 1; i >= 0; i--) {
          if (photos[i].selected) photos.splice(i, 1);
        }
        selectMode = false;
        updateSelectModeUI();
        renderGallery();
        showToast(`${count} photo${count !== 1 ? 's' : ''} deleted`);
      }
    );
  });

  // Save selected
  document.getElementById('btn-save-selected').addEventListener('click', async () => {
    const selected = photos.filter(p => p.selected);
    if (selected.length === 0) return;
    await savePhotos(selected);
    photos.forEach(p => p.selected = false);
    selectMode = false;
    updateSelectModeUI();
    renderGallery();
  });

  // Save all
  document.getElementById('btn-save-all').addEventListener('click', async () => {
    if (photos.length === 0) { showToast('No photos to save'); return; }
    await savePhotos(photos);
  });

  // ===== BATCH AUTO-CROP =====
  btnBatchCrop.addEventListener('click', () => {
    const uncropped = photos.filter(p => !p.cropped);
    if (uncropped.length === 0) { showToast('All photos already cropped'); return; }
    runBatchAutoCrop(uncropped);
  });

  function runBatchAutoCrop(targets) {
    batchOverlay.classList.add('visible');
    let processed = 0;
    let success = 0;
    const total = targets.length;
    batchFill.style.width = '0%';
    batchStatus.textContent = `0 / ${total}`;

    function advance() {
      processed++;
      batchFill.style.width = Math.round((processed / total) * 100) + '%';
      batchStatus.textContent = `${processed} / ${total}`;
      setTimeout(processNext, 20);
    }

    function processNext() {
      if (processed >= total) {
        batchOverlay.classList.remove('visible');
        renderGallery();
        showToast(`Auto-cropped ${success} of ${total} photos`);
        return;
      }
      const photo = targets[processed];
      const bounds = detectProjectBounds(photo);
      if (bounds) {
        applyAutoCropToPhoto(photo, bounds, () => { success++; advance(); });
      } else {
        advance();
      }
    }
    setTimeout(processNext, 50);
  }

  function applyAutoCropToPhoto(photo, rect, callback) {
    const img = photo.currentImg;
    const rot = photo.rotation;
    let w, h;
    if (rot === 90 || rot === 270) { w = img.height; h = img.width; }
    else { w = img.width; h = img.height; }

    const tmpC = document.createElement('canvas');
    const tmpCtx = tmpC.getContext('2d');
    tmpC.width = w;
    tmpC.height = h;
    tmpCtx.translate(w / 2, h / 2);
    tmpCtx.rotate(rot * Math.PI / 180);
    tmpCtx.drawImage(img, -img.width / 2, -img.height / 2);

    const sx = Math.max(0, Math.round(rect.x));
    const sy = Math.max(0, Math.round(rect.y));
    const sw = Math.min(w - sx, Math.round(rect.w));
    const sh = Math.min(h - sy, Math.round(rect.h));
    if (sw < 10 || sh < 10) { if (callback) callback(); return; }

    const imgData = tmpCtx.getImageData(sx, sy, sw, sh);
    const cropC = document.createElement('canvas');
    cropC.width = sw;
    cropC.height = sh;
    cropC.getContext('2d').putImageData(imgData, 0, 0);

    const newImg = new Image();
    newImg.onload = () => {
      photo.currentImg = newImg;
      photo.rotation = 0;
      photo.cropped = true;
      invalidateThumb(photo);
      if (callback) callback();
    };
    newImg.src = cropC.toDataURL();
  }

  // ===== EDITOR =====
  function openEditor(idx) {
    activeIndex = idx;
    showScreen('editor');
    exitCropMode();
    autoCropBanner.classList.remove('visible');
    loadActivePhoto();
    // Only auto-scan if not already cropped
    const photo = getActive();
    if (photo && !photo.cropped) {
      runAutoCrop();
    }
  }

  document.getElementById('btn-back').addEventListener('click', () => {
    exitCropMode();
    showScreen('gallery');
    renderGallery();
  });

  function getActive() { return photos[activeIndex] || null; }

  function loadActivePhoto() {
    const photo = getActive();
    if (!photo) return;
    editorName.value = photo.name;
    editorCounter.textContent = `${activeIndex + 1} / ${photos.length}`;
    drawPhoto();
    document.getElementById('btn-prev').disabled = activeIndex <= 0;
    document.getElementById('btn-next').disabled = activeIndex >= photos.length - 1;
  }

  editorName.addEventListener('input', () => {
    const photo = getActive();
    if (photo) photo.name = editorName.value;
  });

  function navigateTo(idx) {
    activeIndex = idx;
    exitCropMode();
    autoCropBanner.classList.remove('visible');
    loadActivePhoto();
    const photo = getActive();
    if (photo && !photo.cropped) runAutoCrop();
  }

  document.getElementById('btn-prev').addEventListener('click', () => {
    if (activeIndex > 0) navigateTo(activeIndex - 1);
  });
  document.getElementById('btn-next').addEventListener('click', () => {
    if (activeIndex < photos.length - 1) navigateTo(activeIndex + 1);
  });

  // Swipe
  let swipeStartX = null;
  editorCanvasArea.addEventListener('touchstart', (e) => {
    if (cropMode) return;
    swipeStartX = e.touches[0].clientX;
  }, { passive: true });
  editorCanvasArea.addEventListener('touchend', (e) => {
    if (cropMode || swipeStartX === null) return;
    const dx = e.changedTouches[0].clientX - swipeStartX;
    swipeStartX = null;
    if (Math.abs(dx) > 60) {
      if (dx < 0 && activeIndex < photos.length - 1) navigateTo(activeIndex + 1);
      else if (dx > 0 && activeIndex > 0) navigateTo(activeIndex - 1);
    }
  }, { passive: true });

  function drawPhoto() {
    const photo = getActive();
    if (!photo) return;
    const img = photo.currentImg;
    const rot = photo.rotation;
    let w, h;
    if (rot === 90 || rot === 270) { w = img.height; h = img.width; }
    else { w = img.width; h = img.height; }
    canvas.width = w;
    canvas.height = h;
    ctx.clearRect(0, 0, w, h);
    ctx.save();
    ctx.translate(w / 2, h / 2);
    ctx.rotate(rot * Math.PI / 180);
    ctx.drawImage(img, -img.width / 2, -img.height / 2);
    ctx.restore();
  }

  // Rotate
  document.getElementById('tool-rotate-left').addEventListener('click', () => {
    const p = getActive(); if (!p) return;
    p.rotation = (p.rotation + 270) % 360;
    invalidateThumb(p);
    drawPhoto();
  });
  document.getElementById('tool-rotate-right').addEventListener('click', () => {
    const p = getActive(); if (!p) return;
    p.rotation = (p.rotation + 90) % 360;
    invalidateThumb(p);
    drawPhoto();
  });

  // Undo — reset to original
  document.getElementById('tool-undo').addEventListener('click', () => {
    const p = getActive(); if (!p) return;
    if (p.currentImg === p.originalImg && p.rotation === 0) {
      showToast('Nothing to undo');
      return;
    }
    p.currentImg = p.originalImg;
    p.rotation = 0;
    p.cropped = false;
    invalidateThumb(p);
    drawPhoto();
    showToast('Reset to original');
  });

  // ===== PERSPECTIVE FLATTEN =====
  document.getElementById('tool-flatten').addEventListener('click', () => {
    const photo = getActive();
    if (!photo) return;
    scanOverlay.classList.add('visible');
    document.querySelector('.scan-text').textContent = 'Detecting perspective...';

    setTimeout(() => {
      const resultCanvas = detectAndFlatten(photo);
      scanOverlay.classList.remove('visible');
      document.querySelector('.scan-text').textContent = 'Scanning for project edges...';

      if (resultCanvas) {
        const newImg = new Image();
        newImg.onload = () => {
          photo.currentImg = newImg;
          photo.rotation = 0;
          photo.cropped = true;
          invalidateThumb(photo);
          drawPhoto();
          showToast('Photo flattened');
        };
        newImg.src = resultCanvas.toDataURL();
      } else {
        showToast('Could not detect perspective');
      }
    }, 100);
  });

  function detectAndFlatten(photo) {
    // Create full-res source canvas for warp
    const img = photo.currentImg;
    const rot = photo.rotation;
    let fullW, fullH;
    if (rot === 90 || rot === 270) { fullW = img.height; fullH = img.width; }
    else { fullW = img.width; fullH = img.height; }

    const srcCanvas = document.createElement('canvas');
    const srcCtx = srcCanvas.getContext('2d');
    srcCanvas.width = fullW;
    srcCanvas.height = fullH;
    srcCtx.translate(fullW / 2, fullH / 2);
    srcCtx.rotate(rot * Math.PI / 180);
    srcCtx.drawImage(img, -img.width / 2, -img.height / 2);

    // Use shared detection on downsampled image
    const prep = prepareImageData(photo);
    const analysis = analyzeImage(prep.data, prep.sw, prep.sh);
    if (!analysis) return null;
    const { labels, bestLabel } = analysis;
    const sw = prep.sw, sh = prep.sh, scale = prep.scale;

    // Extract contour points of the best component
    const contourPoints = [];
    for (let y = 1; y < sh - 1; y++) {
      for (let x = 1; x < sw - 1; x++) {
        if (labels[y * sw + x] === bestLabel) {
          const isEdge = (
            labels[(y-1)*sw+x] !== bestLabel || labels[(y+1)*sw+x] !== bestLabel ||
            labels[y*sw+(x-1)] !== bestLabel || labels[y*sw+(x+1)] !== bestLabel
          );
          if (isEdge) contourPoints.push({ x, y });
        }
      }
    }

    if (contourPoints.length < 4) return null;

    // Find 4 corners using sum/difference method
    let tlPt = null, trPt = null, blPt = null, brPt = null;
    let minSum = Infinity, maxSum = -Infinity, minDiff = Infinity, maxDiff = -Infinity;
    for (const p of contourPoints) {
      const s = p.x + p.y;
      const d = p.x - p.y;
      if (s < minSum)  { minSum = s;  tlPt = p; }
      if (s > maxSum)  { maxSum = s;  brPt = p; }
      if (d < minDiff) { minDiff = d; blPt = p; }
      if (d > maxDiff) { maxDiff = d; trPt = p; }
    }

    if (!tlPt || !trPt || !blPt || !brPt) return null;

    // Scale corners back to full resolution
    const corners = [
      { x: tlPt.x / scale, y: tlPt.y / scale },
      { x: trPt.x / scale, y: trPt.y / scale },
      { x: brPt.x / scale, y: brPt.y / scale },
      { x: blPt.x / scale, y: blPt.y / scale },
    ];

    // Check if corners form a reasonable quadrilateral
    const topW = Math.hypot(corners[1].x - corners[0].x, corners[1].y - corners[0].y);
    const botW = Math.hypot(corners[2].x - corners[3].x, corners[2].y - corners[3].y);
    const leftH = Math.hypot(corners[3].x - corners[0].x, corners[3].y - corners[0].y);
    const rightH = Math.hypot(corners[2].x - corners[1].x, corners[2].y - corners[1].y);

    const outW = Math.round(Math.max(topW, botW));
    const outH = Math.round(Math.max(leftH, rightH));
    if (outW < 50 || outH < 50) return null;

    return perspectiveWarp(srcCanvas, corners, outW, outH);
  }

  function perspectiveWarp(srcCanvas, corners, outW, outH) {
    // corners: [TL, TR, BR, BL] in source coordinates
    // Compute 3x3 homography from destination rect -> source quad
    const dst = [
      { x: 0, y: 0 },
      { x: outW, y: 0 },
      { x: outW, y: outH },
      { x: 0, y: outH },
    ];

    const H = computeHomography(dst, corners);
    if (!H) return null;

    // Read source pixels
    const srcCtx = srcCanvas.getContext('2d');
    const srcData = srcCtx.getImageData(0, 0, srcCanvas.width, srcCanvas.height);
    const srcPx = srcData.data;
    const srcW = srcCanvas.width;
    const srcH = srcCanvas.height;

    // Create output
    const outCanvas = document.createElement('canvas');
    outCanvas.width = outW;
    outCanvas.height = outH;
    const outCtx = outCanvas.getContext('2d');
    const outData = outCtx.createImageData(outW, outH);
    const outPx = outData.data;

    // For each output pixel, find corresponding source pixel via homography
    for (let oy = 0; oy < outH; oy++) {
      for (let ox = 0; ox < outW; ox++) {
        // Apply H: [sx, sy, sw] = H * [ox, oy, 1]
        const sw2 = H[6] * ox + H[7] * oy + H[8];
        const sx = (H[0] * ox + H[1] * oy + H[2]) / sw2;
        const sy = (H[3] * ox + H[4] * oy + H[5]) / sw2;

        // Bilinear interpolation
        const x0 = Math.floor(sx), y0 = Math.floor(sy);
        const x1 = x0 + 1, y1 = y0 + 1;
        const fx = sx - x0, fy = sy - y0;

        if (x0 >= 0 && x1 < srcW && y0 >= 0 && y1 < srcH) {
          const i00 = (y0 * srcW + x0) * 4;
          const i10 = (y0 * srcW + x1) * 4;
          const i01 = (y1 * srcW + x0) * 4;
          const i11 = (y1 * srcW + x1) * 4;
          const oi = (oy * outW + ox) * 4;

          for (let c = 0; c < 3; c++) {
            outPx[oi + c] = Math.round(
              srcPx[i00+c] * (1-fx) * (1-fy) +
              srcPx[i10+c] * fx * (1-fy) +
              srcPx[i01+c] * (1-fx) * fy +
              srcPx[i11+c] * fx * fy
            );
          }
          outPx[oi + 3] = 255;
        }
      }
    }

    outCtx.putImageData(outData, 0, 0);
    return outCanvas;
  }

  function computeHomography(src, dst) {
    // DLT: solve 8 equations for 8 unknowns (h9 = 1) via Gaussian elimination
    const M = [];
    const b = [];
    for (let i = 0; i < 4; i++) {
      const sx = src[i].x, sy = src[i].y;
      const dx = dst[i].x, dy = dst[i].y;
      M.push([sx, sy, 1, 0, 0, 0, -dx*sx, -dx*sy]);
      b.push(dx);
      M.push([0, 0, 0, sx, sy, 1, -dy*sx, -dy*sy]);
      b.push(dy);
    }

    // Gaussian elimination
    const n = 8;
    const aug = M.map((row, i) => [...row, b[i]]);

    for (let col = 0; col < n; col++) {
      // Find pivot
      let maxVal = 0, maxRow = col;
      for (let row = col; row < n; row++) {
        if (Math.abs(aug[row][col]) > maxVal) {
          maxVal = Math.abs(aug[row][col]);
          maxRow = row;
        }
      }
      if (maxVal < 1e-10) return null;

      // Swap
      [aug[col], aug[maxRow]] = [aug[maxRow], aug[col]];

      // Eliminate
      for (let row = 0; row < n; row++) {
        if (row === col) continue;
        const factor = aug[row][col] / aug[col][col];
        for (let j = col; j <= n; j++) {
          aug[row][j] -= factor * aug[col][j];
        }
      }
    }

    const h = [];
    for (let i = 0; i < n; i++) {
      h.push(aug[i][n] / aug[i][i]);
    }
    h.push(1); // h9

    return h;
  }

  // ===== AI AUTO-CROP (IMPROVED) =====
  document.getElementById('tool-auto-crop').addEventListener('click', () => runAutoCrop());

  function runAutoCrop() {
    const photo = getActive();
    if (!photo) return;
    scanOverlay.classList.add('visible');
    autoCropBanner.classList.remove('visible');

    setTimeout(() => {
      autoCropResult = detectProjectBounds(photo);
      scanOverlay.classList.remove('visible');

      if (autoCropResult) {
        showAutoCropPreview(autoCropResult);
        autoCropBanner.classList.add('visible');
      } else {
        autoCropBanner.classList.remove('visible');
      }
    }, 100);
  }

  // ===== SHARED IMAGE ANALYSIS =====
  function prepareImageData(photo) {
    const img = photo.currentImg;
    const rot = photo.rotation;
    let w, h;
    if (rot === 90 || rot === 270) { w = img.height; h = img.width; }
    else { w = img.width; h = img.height; }
    const maxDim = 500;
    const scale = Math.min(maxDim / w, maxDim / h, 1);
    const sw = Math.round(w * scale);
    const sh = Math.round(h * scale);
    const tmpC = document.createElement('canvas');
    const tmpCtx = tmpC.getContext('2d');
    tmpC.width = sw;
    tmpC.height = sh;
    tmpCtx.translate(sw / 2, sh / 2);
    tmpCtx.rotate(rot * Math.PI / 180);
    tmpCtx.drawImage(img, -img.width * scale / 2, -img.height * scale / 2, img.width * scale, img.height * scale);
    return { data: tmpCtx.getImageData(0, 0, sw, sh).data, sw, sh, scale };
  }

  function analyzeImage(data, sw, sh) {
    // Grayscale + blur + Sobel edges
    const gray = new Float32Array(sw * sh);
    for (let i = 0; i < sw * sh; i++) {
      const ri = i * 4;
      gray[i] = 0.299 * data[ri] + 0.587 * data[ri+1] + 0.114 * data[ri+2];
    }
    const blurred = gaussianBlur3x3(gray, sw, sh);
    const edges = sobelEdges(blurred, sw, sh);

    // Color gradient magnitude (RGB Sobel — catches edges between same-brightness colors)
    const colorEdges = new Float32Array(sw * sh);
    for (let y = 1; y < sh - 1; y++) {
      for (let x = 1; x < sw - 1; x++) {
        let maxGrad = 0;
        for (let c = 0; c < 3; c++) {
          const tl = data[((y-1)*sw+(x-1))*4+c], tc = data[((y-1)*sw+x)*4+c], tr = data[((y-1)*sw+(x+1))*4+c];
          const ml = data[(y*sw+(x-1))*4+c],                                     mr = data[(y*sw+(x+1))*4+c];
          const bl = data[((y+1)*sw+(x-1))*4+c], bc = data[((y+1)*sw+x)*4+c], br = data[((y+1)*sw+(x+1))*4+c];
          const gx = -tl - 2*ml - bl + tr + 2*mr + br;
          const gy = -tl - 2*tc - tr + bl + 2*bc + br;
          const mag = Math.sqrt(gx*gx + gy*gy);
          if (mag > maxGrad) maxGrad = mag;
        }
        colorEdges[y * sw + x] = maxGrad;
      }
    }

    // Background color from border band
    const bandW = Math.max(4, Math.round(sw * 0.1));
    const bandH = Math.max(4, Math.round(sh * 0.1));
    const borderPixels = [];
    for (let y = 0; y < sh; y++) {
      for (let x = 0; x < sw; x++) {
        if (y < bandH || y >= sh - bandH || x < bandW || x >= sw - bandW) {
          const ri = (y * sw + x) * 4;
          borderPixels.push([data[ri], data[ri+1], data[ri+2]]);
        }
      }
    }
    const bgR = median(borderPixels.map(p => p[0]));
    const bgG = median(borderPixels.map(p => p[1]));
    const bgB = median(borderPixels.map(p => p[2]));

    // Color distance from background + Otsu threshold
    const colorDists = new Float32Array(sw * sh);
    for (let i = 0; i < sw * sh; i++) {
      const ri = i * 4;
      const dr = data[ri] - bgR, dg = data[ri+1] - bgG, db = data[ri+2] - bgB;
      colorDists[i] = Math.sqrt(dr*dr + dg*dg + db*db);
    }
    const colorThreshold = otsuThreshold(colorDists, sw * sh);

    // Edge thresholds
    let edgeMax = 0;
    for (let i = 0; i < edges.length; i++) if (edges[i] > edgeMax) edgeMax = edges[i];
    const edgeThreshold = edgeMax * 0.15;
    let colorEdgeMax = 0;
    for (let i = 0; i < colorEdges.length; i++) if (colorEdges[i] > colorEdgeMax) colorEdgeMax = colorEdges[i];
    const colorEdgeThreshold = colorEdgeMax * 0.12;

    // Combined mask
    const mask = new Uint8Array(sw * sh);
    for (let i = 0; i < sw * sh; i++) {
      mask[i] = (colorDists[i] > colorThreshold || edges[i] > edgeThreshold || colorEdges[i] > colorEdgeThreshold) ? 1 : 0;
    }

    // Morphological close then open
    const radius = Math.max(2, Math.round(Math.min(sw, sh) * 0.008));
    const closed = morphDilate(mask, sw, sh, radius);
    const closedEroded = morphErode(closed, sw, sh, radius);
    const opened = morphErode(closedEroded, sw, sh, radius + 1);
    const cleaned = morphDilate(opened, sw, sh, radius + 1);

    // Connected components with centroid tracking
    const labels = new Int32Array(sw * sh);
    labels.fill(-1);
    const comps = [];
    let nextLabel = 0;
    for (let y = 0; y < sh; y++) {
      for (let x = 0; x < sw; x++) {
        const idx = y * sw + x;
        if (cleaned[idx] && labels[idx] === -1) {
          const label = nextLabel++;
          let size = 0, sumX = 0, sumY = 0;
          const queue = [idx];
          labels[idx] = label;
          while (queue.length > 0) {
            const ci = queue.pop();
            size++;
            const cx = ci % sw;
            const cy = (ci - cx) / sw;
            sumX += cx; sumY += cy;
            const neighbors = [
              cy > 0 ? ci - sw : -1, cy < sh - 1 ? ci + sw : -1,
              cx > 0 ? ci - 1 : -1, cx < sw - 1 ? ci + 1 : -1,
            ];
            for (const ni of neighbors) {
              if (ni >= 0 && cleaned[ni] && labels[ni] === -1) { labels[ni] = label; queue.push(ni); }
            }
          }
          comps.push({ label, size, sumX, sumY });
        }
      }
    }
    if (comps.length === 0) return null;

    // Score by size * centrality (prefer centered objects)
    const halfW = sw / 2, halfH = sh / 2;
    const maxDist = Math.hypot(halfW, halfH);
    for (const c of comps) {
      const centX = c.sumX / c.size;
      const centY = c.sumY / c.size;
      const dist = Math.hypot(centX - halfW, centY - halfH);
      const centrality = 1 - (dist / maxDist);
      c.score = c.size * centrality * centrality;
    }
    comps.sort((a, b) => b.score - a.score);

    const bestLabel = comps[0].label;
    const fgRatio = comps[0].size / (sw * sh);
    if (fgRatio < 0.05 || fgRatio > 0.92) return null;
    return { labels, bestLabel };
  }

  function detectProjectBounds(photo) {
    const prep = prepareImageData(photo);
    const analysis = analyzeImage(prep.data, prep.sw, prep.sh);
    if (!analysis) return null;
    const { labels, bestLabel } = analysis;
    const sw = prep.sw, sh = prep.sh, scale = prep.scale;

    let minX = sw, minY = sh, maxX = 0, maxY = 0;
    for (let y = 0; y < sh; y++) {
      for (let x = 0; x < sw; x++) {
        if (labels[y * sw + x] === bestLabel) {
          if (x < minX) minX = x;
          if (x > maxX) maxX = x;
          if (y < minY) minY = y;
          if (y > maxY) maxY = y;
        }
      }
    }
    if (maxX - minX < sw * 0.08 || maxY - minY < sh * 0.08) return null;

    const pad = Math.round(Math.min(sw, sh) * 0.015);
    minX = Math.max(0, minX - pad);
    minY = Math.max(0, minY - pad);
    maxX = Math.min(sw - 1, maxX + pad);
    maxY = Math.min(sh - 1, maxY + pad);

    return {
      x: Math.round(minX / scale),
      y: Math.round(minY / scale),
      w: Math.round((maxX - minX) / scale),
      h: Math.round((maxY - minY) / scale),
    };
  }

  // --- Image processing helpers ---
  function gaussianBlur3x3(src, w, h) {
    // 3x3 Gaussian kernel: [1 2 1; 2 4 2; 1 2 1] / 16
    const out = new Float32Array(w * h);
    for (let y = 1; y < h - 1; y++) {
      for (let x = 1; x < w - 1; x++) {
        out[y * w + x] = (
          src[(y-1)*w + (x-1)] * 1 + src[(y-1)*w + x] * 2 + src[(y-1)*w + (x+1)] * 1 +
          src[y*w + (x-1)]     * 2 + src[y*w + x]     * 4 + src[y*w + (x+1)]     * 2 +
          src[(y+1)*w + (x-1)] * 1 + src[(y+1)*w + x] * 2 + src[(y+1)*w + (x+1)] * 1
        ) / 16;
      }
    }
    // Copy edges
    for (let x = 0; x < w; x++) { out[x] = src[x]; out[(h-1)*w + x] = src[(h-1)*w + x]; }
    for (let y = 0; y < h; y++) { out[y*w] = src[y*w]; out[y*w + w - 1] = src[y*w + w - 1]; }
    return out;
  }

  function sobelEdges(gray, w, h) {
    const out = new Float32Array(w * h);
    for (let y = 1; y < h - 1; y++) {
      for (let x = 1; x < w - 1; x++) {
        const tl = gray[(y-1)*w+(x-1)], tc = gray[(y-1)*w+x], tr = gray[(y-1)*w+(x+1)];
        const ml = gray[y*w+(x-1)],                             mr = gray[y*w+(x+1)];
        const bl = gray[(y+1)*w+(x-1)], bc = gray[(y+1)*w+x], br = gray[(y+1)*w+(x+1)];
        const gx = -tl - 2*ml - bl + tr + 2*mr + br;
        const gy = -tl - 2*tc - tr + bl + 2*bc + br;
        out[y * w + x] = Math.sqrt(gx*gx + gy*gy);
      }
    }
    return out;
  }

  function otsuThreshold(values, count) {
    // Find max value to normalize into 256 bins
    let maxVal = 0;
    for (let i = 0; i < count; i++) if (values[i] > maxVal) maxVal = values[i];
    if (maxVal === 0) return 30;
    const bins = 256;
    const hist = new Float64Array(bins);
    for (let i = 0; i < count; i++) {
      const bin = Math.min(bins - 1, Math.floor(values[i] / maxVal * (bins - 1)));
      hist[bin]++;
    }
    for (let i = 0; i < bins; i++) hist[i] /= count;
    // Maximize between-class variance
    let bestT = 0, bestVar = 0;
    let w0 = 0, sum0 = 0, sumAll = 0;
    for (let i = 0; i < bins; i++) sumAll += i * hist[i];
    for (let t = 0; t < bins; t++) {
      w0 += hist[t];
      if (w0 === 0) continue;
      const w1 = 1 - w0;
      if (w1 === 0) break;
      sum0 += t * hist[t];
      const m0 = sum0 / w0;
      const m1 = (sumAll - sum0) / w1;
      const v = w0 * w1 * (m0 - m1) * (m0 - m1);
      if (v > bestVar) { bestVar = v; bestT = t; }
    }
    return clamp((bestT / (bins - 1)) * maxVal, 15, 80);
  }

  function median(arr) {
    const sorted = arr.slice().sort((a, b) => a - b);
    const mid = sorted.length >> 1;
    return sorted.length & 1 ? sorted[mid] : (sorted[mid - 1] + sorted[mid]) / 2;
  }

  function morphErode(mask, w, h, r) {
    // Separable erosion for speed: horizontal then vertical
    const tmp = new Uint8Array(w * h);
    // Horizontal pass
    for (let y = 0; y < h; y++) {
      for (let x = 0; x < w; x++) {
        let all = true;
        for (let dx = -r; dx <= r && all; dx++) {
          const nx = x + dx;
          if (nx < 0 || nx >= w || !mask[y * w + nx]) all = false;
        }
        tmp[y * w + x] = all ? 1 : 0;
      }
    }
    // Vertical pass
    const out = new Uint8Array(w * h);
    for (let y = 0; y < h; y++) {
      for (let x = 0; x < w; x++) {
        let all = true;
        for (let dy = -r; dy <= r && all; dy++) {
          const ny = y + dy;
          if (ny < 0 || ny >= h || !tmp[ny * w + x]) all = false;
        }
        out[y * w + x] = all ? 1 : 0;
      }
    }
    return out;
  }

  function morphDilate(mask, w, h, r) {
    const tmp = new Uint8Array(w * h);
    for (let y = 0; y < h; y++) {
      for (let x = 0; x < w; x++) {
        let any = false;
        for (let dx = -r; dx <= r && !any; dx++) {
          const nx = x + dx;
          if (nx >= 0 && nx < w && mask[y * w + nx]) any = true;
        }
        tmp[y * w + x] = any ? 1 : 0;
      }
    }
    const out = new Uint8Array(w * h);
    for (let y = 0; y < h; y++) {
      for (let x = 0; x < w; x++) {
        let any = false;
        for (let dy = -r; dy <= r && !any; dy++) {
          const ny = y + dy;
          if (ny >= 0 && ny < h && tmp[ny * w + x]) any = true;
        }
        out[y * w + x] = any ? 1 : 0;
      }
    }
    return out;
  }

  function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }

  // ===== AUTO-CROP PREVIEW & ACCEPT =====
  function showAutoCropPreview(rect) {
    const displayW = canvas.clientWidth;
    const displayH = canvas.clientHeight;
    const scaleX = displayW / canvas.width;
    const scaleY = displayH / canvas.height;
    cropRect = {
      x: rect.x * scaleX,
      y: rect.y * scaleY,
      w: rect.w * scaleX,
      h: rect.h * scaleY,
    };
    cropOverlay.classList.add('active');
    cropSelection.classList.add('visible');
    updateCropSelection();
  }

  document.getElementById('btn-accept-auto').addEventListener('click', () => {
    if (autoCropResult) applyCropRect(autoCropResult);
    autoCropBanner.classList.remove('visible');
    cropOverlay.classList.remove('active');
    cropSelection.classList.remove('visible');
    showToast('Crop applied');
  });

  document.getElementById('btn-adjust-auto').addEventListener('click', () => {
    autoCropBanner.classList.remove('visible');
    enterCropMode(); // cropRect already set
  });

  document.getElementById('btn-skip-auto').addEventListener('click', () => {
    autoCropBanner.classList.remove('visible');
    cropOverlay.classList.remove('active');
    cropSelection.classList.remove('visible');
    cropRect = null;
  });

  function applyCropRect(rect) {
    const photo = getActive();
    if (!photo) return;

    drawPhoto();
    const sx = Math.max(0, Math.round(rect.x));
    const sy = Math.max(0, Math.round(rect.y));
    const cw = Math.min(canvas.width - sx, Math.round(rect.w));
    const ch = Math.min(canvas.height - sy, Math.round(rect.h));
    if (cw < 10 || ch < 10) return;

    const imgData = ctx.getImageData(sx, sy, cw, ch);
    const tmpC = document.createElement('canvas');
    tmpC.width = cw;
    tmpC.height = ch;
    tmpC.getContext('2d').putImageData(imgData, 0, 0);

    const newImg = new Image();
    newImg.onload = () => {
      photo.currentImg = newImg;
      photo.rotation = 0;
      photo.cropped = true;
      invalidateThumb(photo);
      drawPhoto();
    };
    newImg.src = tmpC.toDataURL();
  }

  // ===== MANUAL CROP =====
  document.getElementById('tool-manual-crop').addEventListener('click', () => {
    if (cropMode) exitCropMode();
    else enterCropMode();
  });

  function enterCropMode() {
    cropMode = true;
    autoCropBanner.classList.remove('visible');
    cropOverlay.classList.add('active');
    editorToolbar.classList.add('hidden');
    cropToolbar.classList.add('visible');
    if (!cropRect) {
      cropSelection.classList.remove('visible');
    } else {
      cropSelection.classList.add('visible');
      updateCropSelection();
    }
  }

  function exitCropMode() {
    cropMode = false;
    cropOverlay.classList.remove('active');
    cropSelection.classList.remove('visible');
    editorToolbar.classList.remove('hidden');
    cropToolbar.classList.remove('visible');
    cropRect = null;
    cropStart = null;
    draggingHandle = null;
    movingCrop = false;
  }

  document.getElementById('btn-crop-cancel').addEventListener('click', exitCropMode);

  document.getElementById('btn-crop-apply').addEventListener('click', () => {
    if (!cropRect || cropRect.w < 5 || cropRect.h < 5) return;
    const displayW = canvas.clientWidth;
    const displayH = canvas.clientHeight;
    const scaleX = canvas.width / displayW;
    const scaleY = canvas.height / displayH;
    applyCropRect({
      x: cropRect.x * scaleX,
      y: cropRect.y * scaleY,
      w: cropRect.w * scaleX,
      h: cropRect.h * scaleY,
    });
    exitCropMode();
    showToast('Crop applied');
  });

  // --- Crop mouse events ---
  cropOverlay.addEventListener('mousedown', (e) => {
    if (e.target.dataset && e.target.dataset.handle) {
      draggingHandle = e.target.dataset.handle;
      e.preventDefault();
      return;
    }
    if (cropRect && isInsideXY(e.offsetX, e.offsetY)) {
      movingCrop = true;
      moveStart = { x: e.offsetX, y: e.offsetY, cx: cropRect.x, cy: cropRect.y };
      e.preventDefault();
      return;
    }
    cropStart = { x: e.offsetX, y: e.offsetY };
    cropRect = { x: e.offsetX, y: e.offsetY, w: 0, h: 0 };
    cropSelection.classList.add('visible');
    updateCropSelection();
  });

  cropOverlay.addEventListener('mousemove', (e) => {
    if (draggingHandle && cropRect) {
      resizeHandle(draggingHandle, e.offsetX, e.offsetY);
      updateCropSelection();
      return;
    }
    if (movingCrop && cropRect) {
      cropRect.x = clamp(moveStart.cx + e.offsetX - moveStart.x, 0, cropOverlay.clientWidth - cropRect.w);
      cropRect.y = clamp(moveStart.cy + e.offsetY - moveStart.y, 0, cropOverlay.clientHeight - cropRect.h);
      updateCropSelection();
      return;
    }
    if (cropStart) {
      cropRect = {
        x: Math.min(cropStart.x, e.offsetX),
        y: Math.min(cropStart.y, e.offsetY),
        w: Math.abs(e.offsetX - cropStart.x),
        h: Math.abs(e.offsetY - cropStart.y),
      };
      updateCropSelection();
    }
  });

  window.addEventListener('mouseup', () => {
    cropStart = null;
    draggingHandle = null;
    movingCrop = false;
    moveStart = null;
    if (cropRect) {
      if (cropRect.w < 0) { cropRect.x += cropRect.w; cropRect.w = -cropRect.w; }
      if (cropRect.h < 0) { cropRect.y += cropRect.h; cropRect.h = -cropRect.h; }
    }
  });

  // --- Crop touch events ---
  cropOverlay.addEventListener('touchstart', (e) => {
    e.preventDefault();
    const touch = e.touches[0];
    const rect = cropOverlay.getBoundingClientRect();
    const ox = touch.clientX - rect.left;
    const oy = touch.clientY - rect.top;

    const handle = closestHandle(ox, oy);
    if (handle) { draggingHandle = handle; return; }

    if (cropRect && isInsideXY(ox, oy)) {
      movingCrop = true;
      moveStart = { x: ox, y: oy, cx: cropRect.x, cy: cropRect.y };
      return;
    }

    cropStart = { x: ox, y: oy };
    cropRect = { x: ox, y: oy, w: 0, h: 0 };
    cropSelection.classList.add('visible');
    updateCropSelection();
  }, { passive: false });

  cropOverlay.addEventListener('touchmove', (e) => {
    e.preventDefault();
    const touch = e.touches[0];
    const rect = cropOverlay.getBoundingClientRect();
    const ox = touch.clientX - rect.left;
    const oy = touch.clientY - rect.top;

    if (draggingHandle && cropRect) {
      resizeHandle(draggingHandle, ox, oy);
      updateCropSelection();
      return;
    }
    if (movingCrop && cropRect) {
      cropRect.x = clamp(moveStart.cx + ox - moveStart.x, 0, cropOverlay.clientWidth - cropRect.w);
      cropRect.y = clamp(moveStart.cy + oy - moveStart.y, 0, cropOverlay.clientHeight - cropRect.h);
      updateCropSelection();
      return;
    }
    if (cropStart) {
      cropRect = {
        x: Math.min(cropStart.x, ox),
        y: Math.min(cropStart.y, oy),
        w: Math.abs(ox - cropStart.x),
        h: Math.abs(oy - cropStart.y),
      };
      updateCropSelection();
    }
  }, { passive: false });

  cropOverlay.addEventListener('touchend', () => {
    cropStart = null;
    draggingHandle = null;
    movingCrop = false;
    moveStart = null;
  });

  function closestHandle(ox, oy) {
    if (!cropRect) return null;
    const hitDist = 35;
    const corners = {
      nw: { x: cropRect.x, y: cropRect.y },
      ne: { x: cropRect.x + cropRect.w, y: cropRect.y },
      sw: { x: cropRect.x, y: cropRect.y + cropRect.h },
      se: { x: cropRect.x + cropRect.w, y: cropRect.y + cropRect.h },
    };
    let best = null, bestDist = hitDist;
    for (const [name, pt] of Object.entries(corners)) {
      const d = Math.hypot(ox - pt.x, oy - pt.y);
      if (d < bestDist) { bestDist = d; best = name; }
    }
    return best;
  }

  function isInsideXY(ox, oy) {
    if (!cropRect) return false;
    return ox >= cropRect.x && ox <= cropRect.x + cropRect.w &&
           oy >= cropRect.y && oy <= cropRect.y + cropRect.h;
  }

  function resizeHandle(handle, mx, my) {
    const r = cropRect;
    if (handle === 'se') { r.w = mx - r.x; r.h = my - r.y; }
    if (handle === 'sw') { r.w += r.x - mx; r.x = mx; r.h = my - r.y; }
    if (handle === 'ne') { r.w = mx - r.x; r.h += r.y - my; r.y = my; }
    if (handle === 'nw') { r.w += r.x - mx; r.h += r.y - my; r.x = mx; r.y = my; }
  }

  function updateCropSelection() {
    if (!cropRect) return;
    const s = cropSelection.style;
    s.left = cropRect.x + 'px';
    s.top = cropRect.y + 'px';
    s.width = Math.max(0, cropRect.w) + 'px';
    s.height = Math.max(0, cropRect.h) + 'px';
    updateShades();
  }

  function updateShades() {
    const ow = cropOverlay.clientWidth;
    const oh = cropOverlay.clientHeight;
    const st = document.getElementById('shade-top');
    const sr = document.getElementById('shade-right');
    const sb = document.getElementById('shade-bottom');
    const sl = document.getElementById('shade-left');

    if (!cropRect || cropRect.w <= 0 || cropRect.h <= 0) {
      st.style.cssText = sr.style.cssText = sb.style.cssText = sl.style.cssText = 'display:none';
      return;
    }
    const { x, y, w: cw, h: ch } = cropRect;
    st.style.cssText = `top:0;left:0;width:${ow}px;height:${y}px;`;
    sb.style.cssText = `top:${y+ch}px;left:0;width:${ow}px;height:${oh-y-ch}px;`;
    sl.style.cssText = `top:${y}px;left:0;width:${x}px;height:${ch}px;`;
    sr.style.cssText = `top:${y}px;left:${x+cw}px;width:${ow-x-cw}px;height:${ch}px;`;
  }

  // ===== SAVE =====
  document.getElementById('tool-save').addEventListener('click', async () => {
    const p = getActive();
    if (p) await savePhotos([p]);
  });

  function renderPhotoBlob(photo) {
    return new Promise((resolve) => {
      const img = photo.currentImg;
      const rot = photo.rotation;
      const tmpC = document.createElement('canvas');
      const tmpCtx = tmpC.getContext('2d');
      let w, h;
      if (rot === 90 || rot === 270) { w = img.height; h = img.width; }
      else { w = img.width; h = img.height; }
      tmpC.width = w;
      tmpC.height = h;
      tmpCtx.translate(w / 2, h / 2);
      tmpCtx.rotate(rot * Math.PI / 180);
      tmpCtx.drawImage(img, -img.width / 2, -img.height / 2);
      tmpC.toBlob((blob) => resolve(blob), 'image/jpeg', 0.92);
    });
  }

  async function savePhotos(list) {
    const files = [];
    for (const photo of list) {
      const blob = await renderPhotoBlob(photo);
      if (blob) {
        const name = (photo.name || 'photo') + '.jpg';
        files.push(new File([blob], name, { type: 'image/jpeg' }));
      }
    }
    if (files.length === 0) return;

    // Single photo: try File System Access API (desktop Chrome/Edge — native "Save As" dialog)
    if (files.length === 1 && window.showSaveFilePicker) {
      try {
        const handle = await window.showSaveFilePicker({
          suggestedName: files[0].name,
          types: [{ description: 'JPEG Image', accept: { 'image/jpeg': ['.jpg', '.jpeg'] } }],
        });
        const writable = await handle.createWritable();
        await writable.write(files[0]);
        await writable.close();
        showToast('Photo saved');
        return;
      } catch (e) {
        if (e.name === 'AbortError') return; // user cancelled
      }
    }

    // Try Web Share API (iOS Safari — lets user save to Photos, Files, etc.)
    if (navigator.share && navigator.canShare) {
      const shareData = { files, title: 'Student Photos' };
      if (navigator.canShare(shareData)) {
        try {
          await navigator.share(shareData);
          showToast(`${files.length} photo${files.length !== 1 ? 's' : ''} shared`);
          return;
        } catch (e) {
          if (e.name === 'AbortError') return; // user cancelled
        }
      }
    }

    // Fallback: blob URL downloads
    for (const file of files) {
      const url = URL.createObjectURL(file);
      const link = document.createElement('a');
      link.href = url;
      link.download = file.name;
      link.click();
      setTimeout(() => URL.revokeObjectURL(url), 5000);
      if (files.length > 1) await new Promise(r => setTimeout(r, 300));
    }
    showToast(`${files.length} photo${files.length !== 1 ? 's' : ''} saved`);
  }

  // ===== INIT =====
  renderGallery();

  // Register service worker for PWA
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('sw.js').catch(() => {});
  }
})();
</script>
</body>
</html>
